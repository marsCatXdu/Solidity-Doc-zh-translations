# 智能合约简介（Introduction to Smart Contracts）

> 本文对应 solidity 版本 0.8.13 ，文档版本 abaa5c0e
>
> 原文 [Introduction to Smart Contracts — Solidity 0.8.13 documentation (soliditylang.org)](https://docs.soliditylang.org/en/v0.8.13/introduction-to-smart-contracts.html)

## 一个简单的智能合约

下面是使用函数设置变量值的示例，该代码还通过一个函数将变量暴露给其他合约。不必在意不理解的细节，后面都会逐步给出详细说明

### 存储示例

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}
```

第一行说明该代码文件使用 GPL-3 开源协议，该注释能够被机器解析。如果你要发布源代码，那这条指定协议的东西就是默认要加的。

第二行指定了该代码所用的 solidity 语言版本是大于等于 0.4.16、小于 0.9.0 的。不满足该版本要求的编译器不会对代码进行编译，由此可以避免语言版本变动引发的代码行为差异问题。Pragmas 指令可以控制编译器处理源代码的方式。

智能合约是由代码指令（即“函数”）和数据（即“状态”）组成的，其被作为一个整体存储在 Ethereum 区块链的某个地址上（这也就意味着我们可以通过这个地址来找到它）。 `uint storedData;` 这一行声明了一个 `uint` 类型的状态变量（256位的无符号整数），该变量可以被理解为数据库中的一个字段，我们可以通过调用管理数据库的代码来修改该值——在该例的代码中通过定义 `get` 和 `set` 函数来实现。

与常见的面向对象语言不同，solidity 访问当前合约自己的成员通常不需要在名字前加 `this` 关键字。需要注意的是，在 Solidity 中，是否用 this 关键字会影响访问成员时的具体行为，相关内容将在后面做详细说明。

上面的这段代码实现了存取整数值的功能。该代码会被公开存储在 Ethereum 区块链上，任何人都能通过调用 set 来修改变量的值，但 Ethereum 本身的特性决定了所有该整数的历史值都会永远保留在区块链中。下面我们会介绍如何对修改该值进行权限控制

> 警告：需要小心处理 Unicode 文本。Unicode 字符与其他类似（或看起来完全相同）的其他编码字符很可能有不同的码位（code points），这可能会导致代码被编码为与预期不符的结果

> 注意：所有的标识符（合约名、函数名、变量名）都必须使用 ASCII 字符集编码，但在字符串变量中存储 UTF-8 编码的数据是合法的

### 子货币示例

下面的合约实现了一种最简单的加密货币。该合约只允许其创造者创建新的币（作者可以根据需要定制自己的发行规则）。任何拥有一个ethereum密钥对的人都可以相互转账，不需要单独注册账户

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

contract Coin {
    // 关键字 "public" 让其他合约也能够访问该变量
    address public minter;
    mapping (address => uint) public balances;

    // 事件（event）允许用户根据你预先声明的合约行为，做出特定的反应
    event Sent(address from, address to, uint amount);

    // 构造函数只会在合约创建时运行一次
    constructor() {
        minter = msg.sender;
    }

    // 向给定地址发送一定量新造的币。该函数只能由合约创建者调用
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        balances[receiver] += amount;
    }

    // 错误（Errors）可用于给出导致操作失败的原因，其会返回给函数的调用者
    error InsufficientBalance(uint requested, uint available);

    // 将交易发送者已有的币发送给其他地址
    function send(address receiver, uint amount) public {
        if (amount > balances[msg.sender])
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}
```

该合约引出了一些新的概念，接下来我们将逐个介绍

`address public minter;`这行声明了一个 `address` 类型的状态变量。地址类型是一个 160bit 长的值，且不允许进行任何算术操作。该类型的变量适合存储合约地址，或外部账户密钥对公共部分的 hash 值。

`public` 关键字能够自动生成一个 getter 函数（该函数的名字与被修饰的变量相同），让我们能在合约外面直接取到状态变量的当前值。如果没有该关键字，其他合约就无法读取该变量的值了。函数的代码由编译器生成，与下面例子中的函数等价（请暂时忽略 `external` 和 `view` 关键字）：

```solidity
function minter() external view returns (address) { return minter; }
```

你也可以自己手动添加上面这样的函数，但函数名需要和对应的状态变量名保持一致。

下一行的 `mapping (address => unit) public balances;` 也会创建一个公共的状态变量，但这个变量的结构更加复杂一点——这是一个从地址到无符号整数的映射类型变量。

映射可以看做是一个进行了虚拟初始化的哈希表，每个键都映射到了一个全0值的值。当然，不可能真的初始化那么大的表，也不可能列出所有的值，只是行为上如此（译注：表现为访问任何一个键都能取回一个全0的值）。映射类型可用于记录任何添加到映射中的东西。

mapping 类型默认产生的 getter 函数复杂一些，大致如下：

```solidity
function balances(address account) external view returns (uint) {
    return balances[account];
}
```

在这个例子中，我们可以利用这个函数来查询某个特定账号的余额。

`event Sent(address from, address to, uint amount);` 这一行声明了一个 “事件”，其会在 `send` 函数的最后一行被触发。如 web 应用这样的 Ethereum 客户端能够以不大的开销来在区块链上监听事件的触发。一旦事件被触发，监听者就能够接收到 `from`, `to`, `amount` 参数，实现追踪交易的需求。

对该事件的监听可以通过下面的 JavaScript 代码实现，其利用 web3.js 库来创建 `Coin` 合约对象来监听事件，并调用上面自动生成的 `balances` 函数来查询相关的信息。

```solidity
Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
})
```

构造函数（ constructor ）是一个只会在合约创建时执行一次的特殊函数。本例中的构造函数会将本合约创建者的地址永久存储在合约中。`msg` 变量（与之类似的还有 `tx`、`block` 变量）是一个特殊的全局变量，其允许访问一些区块链本身的属性。`msg.sender` 的值总是调用当前函数的地址。

构造函数进行合约的创建，`mint` 和 `send` 函数则是可供用户及其他合约调用的。

`mint` 函数会新创建一些币，然后将这些币发给指定的地址。`require` 函数用于检查某些条件是否满足，并在不满足的情况下回滚所有操作。在这个例子中，`require(msg.sender == minter);` 用于确保只有合约的创建者才能调用 `mint` 函数。通常情况下，合约创建者可以随心所欲地创建新的币，但在某一时刻可能会引起被称为“溢出”的问题。由于默认算术检查机制的存在，当表达式 `balances[receiver] += amount;` 溢出时，交易会自动回滚——即，当 `balances[receiver] + amount` 在任意精度的计算中，一旦其值超出了 `uint` 的最大值（`2**256-1`），都会导致交易的回滚。该规则对于`send` 函数中的 `balances[receiver] += amount;` 语句也有一样的效果。

错误（ Error ）能让程序在条件不满足或操作失败时，为调用者返回更多有关失败的详细信息。错误会与回滚（ revert ）操作一同使用。`revert` 语句和 `require` 函数类似，能够无条件地中止代码执行并回滚本次调用中的所有变更，但除此之外，`revert` 还能够为调用者提供错误的名称等额外信息（这些信息最终会被返回到前端应用或区块链浏览器中进行展示），以帮助用户进行调试等。

`send` 函数可以被任何拥有一些这个币的用户调用，来把他们自己的币发给任何人。如果发送者没有足够的币，`if` 中的值会为 true ，这会引起该分支中 `revert` 的执行，通过 `InsufficientBalance` 错误为发送者提供详细信息后回滚操作。

> 注意：
>
> 如果使用该合约向某个地址转币，即使转了之后也是无法通过区块链浏览器在这个账户上看到转进去的数字的：这是因为你转进去的币的记录只会存储在你这个币的合约中。
>
> 如有需要，可以借助事件机制来制作一个专门用于跟踪该合约币交易的“区块链浏览器”——这需要对该币的合约地址进行监控来得到币所有者的余额，而该币所有者本身的地址上是体现不出来该币余额的



## 区块链基础知识

对于程序员来说，区块链并不是一个复杂的概念。让区块链看起来很复杂的那些词（挖矿、哈希运算、椭圆曲线、密码学、点对点网络等）实际上都只是提供了一些支撑平台运行的特性。作为开发者只需要知道大致有这些东西即可，而不必过于深究底层技术细节 - 就像未必需要了解云计算的细节，也不妨碍用好各种云服务一样。

### 交易

区块链是一个全局共享的事务型数据库，任何参与进网络的人都能读取数据库中的任何信息。如果想要修改数据库的数据，需要创建一种被称为“交易”的东西并让网络中的所有人都接受这个修改。每个交易中对数据的所有修改只会有成功和失败两种结果，而不存在中间状态（例如要在一个交易中更新两个值，要么都更新成功，要么都失败，而不会出现只成功修改其中一个的情况）。此外，当一个交易在数据库中生效之后，也无法用其他交易来修改这个结果。

例如，假设有一个记录着账户和其对应余额的数据表，如果想要把一个账户上的钱转到另一个账户上，那么接收转账的账户上增加的数字，一定与转出账户上减少的数字相等。如果有某种意外情况导致接收账户的数字修改失败，那转出账户上的数字也一定不能有任何变化。

此外，交易需要由交易的创建者使用某些基于密码的工具进行签名。这个签名机制让数据库修改的逻辑安全而又简洁。就比如在上面这个转账的例子中，想要确定发送者是否有对其转出金额的账户的所有权，只需检查发送者的密钥即可。

### 区块

区块链中一个不太好理解的常见术语是“双花攻击”：如果有两个交易都想转出同一个账户中所有的余额，那这两个交易中必定只能有一个成功生效（其中一个把钱转走，另一个就没钱可转了），按常识来说，这两个交易中排在前面的那个应该会成功。然而区块链使用的点对点通信是无法保障先后顺序的。

区块链的某些机制能够保证这两个交易请求中只会有一个被留下：区块链中一段时间内的所有交易都会被处理交易的节点打包为一个被称为“区块”的东西，节点在打包的过程中会对所有交易进行检查——如果节点发现了上文中那样相互冲突的两个交易，那就会留下它自己看到的第一个交易，并让第二个交易失败。这样，每个打包好的区块中就不存在相冲突的交易了，然后再让该区块在所有的网络参与节点之间进行传递和扩散。

这些区块按出现的时间顺序连接、排列起来，就组成了“区块链”。区块链会以基本固定的时间间隔不断往后面增加新的区块 - Ethereum 中每两个块之间的间隔大概是 17 秒。

> 注意
>
> 某一时刻发出的交易不能保证其能被包含在下一个区块或后续的某个区块中，因为在区块中添加哪些交易是由矿工决定的，而与交易提交的先后顺序无关。
>
> 如果想要对智能合约的调用时间进行安排，可以考虑使用智能合约自动化工具或使用某些 oracle （预言机）服务

## 以太坊虚拟机（ Ethereum Virtual Machine ）

### 概述

以太坊虚拟机（ EVM ）是以太坊为其上智能合约提供的运行环境。EVM 是一个完全与外界独立的环境，隔绝程度高于一般的沙盒。其中运行的代码无法访问网络、文件系统以及其他进程，智能合约之间的交互也是有限制的。

### 账户（ Accounts ）

以太坊中有两种账户，每个账户都有一个地址，这两种账户共享同一个地址空间。两种账户分别被称为“外部账户”（ external account ）和合约账户（ contract account ）。前者由密钥对进行控制（即真实世界中的人），后者由与账户保存在一起的代码控制

外部账户的地址根据其公钥确定，合约账户的地址根据合约创建的时间确定（实际上是使用创建者的地址和从该地址发送的交易号（被称为“nonce”）共同确定的）

对于 EVM 来说，上面这两种账户是等价的。

每个账户都有一个被称为“存储”（ storage ）的持久性键值存储空间，这是一个从 256 位字到 256 位字的映射。

每个账户还有一个以 Ether 表示的“余额(balance)”，（更准确地说是以“Wei”表示，1 ether = 10**18 wei ）。该值可以通过发送包含 ether 的交易来进行修改

### 交易（ Transactions ）

交易是从一个账户发到另一个账户的消息（ message ），其可包含二进制数据（被称为“payload”）和 Ether。

如果目标账户包含代码，那么该交易的 payload 将作为目标账户代码的输入数据，触发代码的执行。

如果目标账户不存在（交易没有设置接收者或接收者值为 `null` ），该交易就会创建一个新的合约。就像前面提到过的，该新合约的地址是根据发送者的地址和其发送的交易号计算得出的。这样用来创建合约的交易中的 payload 会被当做是 EVM 字节码并会在交易处理时执行。这次执行的输出数据会被作为合约的代码永久存储。也就是说，实际发送的创建合约的交易中包含的代码是“能够返回真正合约代码”的代码，而非合约代码本身。

> 注意
>
> 在合约创建过程中，其代码域还是空的。因此在合约的构造函数返回前，不应调用正在创建的合约

### Gas

每个交易在创建后都需要收取一定量的 gas，gas 用于限制交易所包含的实际计算量，也会被发给处理交易的矿工作为报酬。交易包含的 gas 会在 EVM 处理交易的过程中根据一些标准被逐渐消耗掉。

gas price 是由合约创建者指定的值，创建者需要从自己的账户预先支付 `gas_price * gas` 的 Ether 。如果在交易完成后还有 gas 剩余，其会被退还给交易创建者。

若 gas 在交易处理的过程中被耗尽，则会触发一个 gas 耗尽（ out-of-gas ）异常，该异常会回滚所有的修改，将一切恢复到处理交易之前的状态。

### 存储，内存和栈（ Storage, Memory and the Stack ）

以太坊虚拟机有三个能够存储数据的地方：Storage， Memory 和 Stack。

每个账户都有一个名为 storage 的数据存储区域，其在两次函数调用和交易之前是保持不变的（译注：可以被这两者修改）。Storage 是一个键值存储空间，键和值都是 256 位字，这是一个大到不可能在一个合约中用完的空间。对 storage 的读写和修改都是非常昂贵的，因此应将计算、缓存等数据都放在合约之外，只在最必要的地方使用 storage 。另需注意，合约只能读写自身的 storage。

第二个存储空间是内存（memory），每次消息调用（ message call，下面会提到 ）都会为被调用的合约创建出一块新的内存空间。内存是线性的，可以按字节寻址，写入宽度可以为 8 位或 256 位，但读取宽度只能为 256 位。 在读写一个没有使用过的内存字时（即一个字空间中的偏移位置处）， 内存会按一个字（ 256 位）为单位进行扩展。在扩展所用的内存空间时需要支付额外的 gas 。内存空间的使用费用随使用空间的平方增长。

EVM 是栈虚拟机而非寄存器虚拟机，其中所有的计算都是在栈（ stack ）上进行的。该栈的最多能容纳 1024 个 256 位宽的元素，对栈的读写只能按照下面这样的方式来在最顶端进行：可以复制栈最上面 16 个元素中的某一个，也可以使用最上面 16 个元素中的某一个来替换掉最顶端的元素。所有其他的运算操作只能取最顶端的一到多个元素进行计算，然后将结果压回到栈中。如果想访问栈中更深处的元素，可以通过将栈顶的一部分元素暂存在 storage、memory 中实现。

### 指令集

EVM 采用最小化设计的指令集，以避免指令集改变带来的潜在共识问题。所有指令都只操作基本数据类型、256 位宽字、内存和字节数组。指令包含算术计算、位运算、逻辑和比较运算类型，也可以进行有条件或无条件的跳转。此外，合约还能读取当前区块相关的信息，如块号和时间戳等。

完整指令集列表，请参阅内嵌汇编文档中的[EVM指令列表](https://docs.soliditylang.org/en/v0.8.13/yul.html#opcodes)

### 消息调用（ Message calls ）

合约可以通过“消息调用”来调用其他合约，也可以向非合约账户发送 ether 。消息调用与交易类似，其中数据都包含发送者、接收者、数据 payload 、ether、gas ，并会返回数据。实际上，每个交易都由一个顶层的消息调用组成，该消息调用又可以创建更多消息调用。

合约可以自己决定要在内部消息调用中消耗掉多少的 gas 以及要留下多少 gas 。如果在内部调用的过程中出现 out-of-gas 异常（或其他任何异常），这些异常都会通过往发起调用的合约的栈顶放一个错误值来通知该合约。在这种情况下，只会消耗掉随调用发送的 gas。在 Solidity 中，发起调用的合约默认会在这种情况下主动产生一个异常，因此调用栈中会有异常“冒泡”的现象。

像前面已经提到过的，被调用合约（这个被调用的合约同时也可以在调用其他合约）会有一个属于他自己的干净的内存空间，并可以读取调用它的 payload - 其会被存储在一个被称为 `calldata` 的特殊区域中。在执行结束后，合约可以将数据返回给调用它的合约，被返回的数据将被存储在调用发起合约预先分配好的内存空间中。所有的调用都是同步（ synchronous ）的。

调用有 1024 层的最大深度限制，这意味着在进行复杂操作时，应优先考虑用循环替代递归。此外，每次消息调用都只能转发 63/64 的 gas ，因此在实际情况下，调用深度要比 1000 更小一点。

### 代理调用 / 调用码和库（ Delegatecall / Callcode and Libraries ）

delegatecall 是一种特殊的消息调用，其与消息调用基本相同，差别在于被调用地址的代码会在发起调用的合约的上下文中运行（而不是自己开辟一个新的上下文），且 `msg.sender` 和 `msg.value` 值并不会在调用中改变。

这意味着合约可以在运行时从另一个地址动态加载代码，且仍然使用当前合约的 storage 、地址和余额，在这个过程中只是从目标地址拿来了可执行的代码到本合约环境中运行。

这是 Solidity 中 ”库（ Library ）“ 特性的基础：可重用的库代码虽然存在另一个合约中，但还是能够访问调用发起合约的 storage 。该特性可用于实现复杂数据结构等。

### 日志（ Logs ）

日志（ logs ）是一种可以在单独的数据结构中索引数据，并将数据映射到区块层级上的方法。其被 Solidity 用于实现事件（ events ）。合约无法获取在其创建之后产生的日志数据，但在区块链之外是可以高效读取到任何日志数据的。日志数据的某些部分会被存储在布隆过滤器（ bloom filters ）中，因此可以安全高效地搜索日志数据。因此网络中的参与者无需下载整条区块链（这样的参与者被称为”轻客户端( light clients )“），也能够找到想要的日志。

### 创建（ Create ）

合约可以使用一个特殊的操作码来创建新的合约（也就是说不用像使用交易创建合约一样，向零地址发送一个交易来创建合约）。这些创建调用（ create call ）和普通的消息调用的唯一区别，在于 payload 在执行并储存为代码后，调用者 / 创建者会在自己的栈上收到新合约地址

### 停用和自毁（Deactivate and Self-destruct）

移除合约代码的唯一方式，是让合约在自己的地址上执行 `selfdestruct` 操作。合约上剩余的 Ether 会被发往预先设置好的地址，storage 数据及代码也会被从 state 中移除。移除合约听起来很有用，但实际上是有潜在危险的——如果某人将 ether 发到被移除的合约上，那这些 ether 就永远丢失了。

> 警告：
>
> 即使合约已经用 `selfdestruct` 移除了，这个被移除的合约仍将是整个区块链历史的一部分，并很可能被绝大多数的以太坊节点保存下来。所以这个 `selfdestruct` 和在硬盘上删除数据并不是一回事

> 注意：
>
> 即使合约的代码不包含 `selfdestruct` 调用，该合约也仍可以通过 `delegatecall` 或 `callcode` 来执行自毁操作

如果想要停用合约，可以考虑通过操作一些能导致所有函数回滚的内部 state 变动来 disable 掉合约。这可以让合约无法再被使用，且会在被调用时立即退回所有 ether

### 预编译合约（ Precompiled Contracts ）

以太坊中有一小部分特殊的合约地址：这些从 1 到 8 的地址包含”预编译合约“代码，它们可以被任何合约调用，但它们的行为（以及 gas 消耗）并不是由存储在这些地址上的 EVM 代码定义的（这些地址并没有代码）而是直接在 EVM 运行时环境中直接实现的。

不同的 EVM 兼容链可能会包含一组不同的预编译合约，以太坊未来也可能会加入一些新的预编译合约，但基本可以假定未来的预编译合约地址都会在 1 到 `0xffff` 之间